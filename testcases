# print
1 2 3 4 . . . <- 4 3 2

# basics
1 2 dup . . . <- 2 2 1
1 2 drop . <- 1
1 2 swap . . <- 1 2

# arithmetics
1 2 + . <- 3
1 2 - . <- -1
3 4 * . <- 12
10 5 / . <- 2
10 4 / . <- 2

# load and store
42 0 ! 0 ? <- 42
42 0 ! 0 @ . <- 42
variable aaa 99 aaa ! aaa @ . <- 99


#function definition
1 : dup2 dup ; 2 dup2 . . <- 2 2


#conditionals

3 4 < . <- -1
3 4 > . <- 0
3 4 < invert . <- 0
4 4 = . <- -1
3 4 < 20 30 > or . <- -1
3 4 < 20 30 < and . <- -1
-1 0 and . <- 0
-1 -1 and . <- -1
-1 -1 or . <- -1
0 0 or . <- 0
0 -1 or . <- -1
0 0 xor . <- 0
-1 -1 xor . <- 0
0 -1 xor . <- -1

#mod
3 3 mod . <- 0
4 3 mod . <- 1
5 3 mod . <- 2
10 5 mod 0 = . <- -1

# execution token basic
1 2 3 ' dup execute . . <- 3 3

#function redefinition

1 : drop dup ; drop . . <- 1 1
#; words: should override 1 with 2
: 1 2 ;  1 . <- 2 
: 1 2 ; : 2 1 ; 1 2 . . <- 2 2
#:noname 1 ; <- leaves an execution token
: n 1 ; n . <- 1
: n 1 ; : n 2 ; n . <- 2
: n 1 ; : n n 2 ; n . . <- 2 1
: n 1 ; : n n 2 ; : n n 3 ; n . . . <- 3 2 1

